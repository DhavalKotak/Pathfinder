{"version":3,"sources":["Grid.js","Node.js","Pathfinder.js","App.js","reportWebVitals.js","index.js"],"names":["Node","props","start","className","style","backgroundColor","borderColor","end","close","path","seen","open","openList","findDistance","endNode","node","Math","abs","x","y","fCost","gCost","hCost","getLowestFCost","lowestNode","forEach","isOpen","findNeighbourNodes","grid","neighbour","neighbourNodes","i","j","find","item","id","isClosed","push","initialGrid","parent","openListIndex","Grid","gridRef","useRef","map","useState","setGrid","changeNode","e","right","currentGrid","current","floor","clientX","offsetLeft","clientWidth","ceil","clientY","offsetTop","button","newNodes","startNode","preventDefault","blockNode","Fragment","onMouseDown","onContextMenu","ref","onClick","currentNode","maxLoops","length","splice","console","log","Pathfind","alert","pathNode","marginTop","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.80de9b9b.chunk.js","sourcesContent":["import React, { useRef,useState } from 'react'\r\nimport { Node } from './Node'\r\nimport { startNode, endNode, blockNode, Pathfind } from './Pathfinder'\r\n\r\nconst initialGrid = []\r\nlet id = 1\r\n    for(let i = 9;i >= 0; i--){\r\n        for(let j = 0;j <= 9; j++){\r\n            initialGrid.push({\r\n                id: id,\r\n                x: j,\r\n                y: i,\r\n                gCost: 0,\r\n                hCost: 0,\r\n                parent: null,\r\n                isOpen: false,\r\n                isClosed: false,\r\n                seen: false,\r\n                start: false,\r\n                end: false,\r\n                openListIndex : 0,\r\n                path: false\r\n            })\r\n            id++\r\n        }\r\n    }\r\n\r\nexport const Grid = () => {\r\n    \r\n    const gridRef = useRef()\r\n    const map = []\r\n    const [grid,setGrid] = useState(initialGrid)\r\n\r\n    const changeNode = (e,right) => {\r\n        const currentGrid = gridRef.current\r\n        let x = Math.floor((e.clientX - currentGrid.offsetLeft)/(currentGrid.clientWidth/10))\r\n        let y = Math.abs(Math.ceil((e.clientY - currentGrid.offsetTop - currentGrid.clientWidth)/(currentGrid.clientWidth/10)))\r\n        if(e.button === 0 && right === 0){\r\n            let newNodes = startNode(x,y,grid)\r\n            setGrid(newNodes)\r\n        }else if(e.button === 2 && right === 1){\r\n            e.preventDefault()\r\n            let newNodes = endNode(x,y,grid)\r\n            setGrid(newNodes)\r\n        }else if(e.button === 1 && right === 0){\r\n            let newNodes = blockNode(x,y,grid)\r\n            setGrid(newNodes)\r\n        }\r\n    }\r\n    const start = () => {\r\n        let path = Pathfind(grid)\r\n        if(path.length === 0){\r\n            alert(\"no path\")\r\n        }\r\n        let newNodes = []\r\n        grid.forEach(node => {\r\n            let item = path.find(pathNode => pathNode.id === node.id)\r\n            if(item)\r\n                newNodes.push(item)\r\n            else\r\n                newNodes.push(node)\r\n            item = false\r\n        })\r\n        setGrid(newNodes)\r\n    }\r\n\r\n    grid.forEach(node => {\r\n        map.push(<Node key={node.id} x={node.x} y={node.y} start={node.start} end={node.end} close={node.isClosed} open={node.isOpen} path={node.path} seen={node.seen}/>)\r\n    })\r\n    \r\n    return(\r\n        <React.Fragment>\r\n            <div className='grid' onMouseDown={e => changeNode(e,0)} onContextMenu={e => {changeNode(e,1)}} ref={gridRef}>\r\n                {map}\r\n            </div>\r\n            <button className='btn-lg btn-primary' onClick={start} style={{marginTop:'30px'}}>Start</button>\r\n        </React.Fragment>\r\n    )\r\n}","import React from 'react'\r\n\r\nexport const Node = (props) => {\r\n    if(props.start === true){\r\n        return(\r\n            <div className='node' style={{backgroundColor: 'red',borderColor: 'grey'}}>\r\n                \r\n            </div>\r\n        )\r\n    }else if(props.end === true){\r\n        return(\r\n            <div className='node' style={{backgroundColor: 'blue',borderColor: 'grey'}}>\r\n                \r\n            </div>\r\n        )\r\n    }else if(props.close === true && props.path === false && props.seen === false){\r\n        return(\r\n            <div className='node close'>\r\n                \r\n            </div>\r\n        )\r\n    }else if(props.open === true){\r\n        return(\r\n            <div className='node open'>\r\n                \r\n            </div>\r\n        )\r\n    }else if(props.path === true){\r\n        return(\r\n            <div className='node path'>\r\n                \r\n            </div>\r\n        )\r\n    }else{\r\n        return(\r\n            <div className='node'>\r\n\r\n            </div>\r\n        )\r\n    }\r\n    \r\n}","const openList = []\r\n\r\nexport const startNode = (x,y,grid) => {\r\n    let newNodes = grid.map(node => {\r\n        if(node.start && (node.x !== x || node.y !== y))\r\n            node.start = false\r\n        if(node.x === x && node.y === y){\r\n            node.start = !node.start\r\n            if(node.end)\r\n                node.end = false\r\n            if(node.isClosed)\r\n                node.isClosed = false\r\n        }            \r\n        return node\r\n    })\r\n    return newNodes\r\n}\r\n\r\nexport const endNode = (x,y,grid) => {\r\n    let newNodes = grid.map(node => {\r\n        if(node.end && (node.x !== x || node.y !== y))\r\n            node.end = false\r\n        if(node.x === x && node.y === y){\r\n            node.end = !node.end\r\n            if(node.isClosed)\r\n                node.isClosed = false\r\n            if(node.start)\r\n                node.start = false\r\n        }\r\n        return node\r\n    })\r\n    return newNodes\r\n}\r\n\r\nexport const blockNode = (x,y,grid) => {\r\n    let newNodes = grid.map(node => {\r\n        if(node.x === x && node.y === y){\r\n            node.isClosed = !node.isClosed\r\n            if(node.end)\r\n                node.end = false\r\n            if(node.start)\r\n                node.start = false\r\n        }\r\n        return node\r\n    })\r\n    return newNodes\r\n}\r\n\r\nexport const addToOpenList = node => {\r\n    node.isOpen = true\r\n    openList.push(node)\r\n}\r\n\r\nexport const closeNode = node => {\r\n    node.seen = true\r\n    node.isOpen = false\r\n    node.isClosed = true\r\n}\r\n\r\nexport const findDistance = (endNode,node) => {\r\n    let x = Math.abs(endNode.x - node.x)\r\n    let y = Math.abs(endNode.y - node.y)\r\n    return (x+y)*10\r\n}\r\n\r\nexport const fCost = node => {\r\n    return node.gCost + node.hCost\r\n}\r\n\r\nexport const getLowestFCost = () => {\r\n    let lowestNode = false\r\n    openList.forEach(node => {\r\n        if(node.isOpen){\r\n            if(!lowestNode){\r\n                lowestNode = node\r\n            }else if(fCost(node) < fCost(lowestNode)){\r\n                lowestNode = node\r\n            }else if(fCost(node) === fCost(lowestNode)){\r\n                if(node.hCost <= lowestNode.hCost)\r\n                    lowestNode = node\r\n            }\r\n        }\r\n    })\r\n    return lowestNode\r\n}\r\n\r\nexport const findNeighbourNodes = (grid,node) => {\r\n    let neighbourNodes = []\r\n    let neighbour\r\n    for(let i = -1; i<=1;i++){\r\n        for(let j = -1; j<=1;j++){\r\n            if(!(i === 0 && j === 0)){\r\n                if(i===-1)\r\n                    neighbour = grid.find(item => node.id+j-10 === item.id)\r\n                else if(i===0)\r\n                    neighbour = grid.find(item => node.id+j === item.id)\r\n                else if(i===1)\r\n                    neighbour = grid.find(item => node.id+10+j === item.id)\r\n            }\r\n            if(neighbour){\r\n                if(neighbour.x >=0 && neighbour.y >=0 && neighbour.x < 11 && neighbour.y < 11){\r\n                    if(!(i === 0 && j === 0)){        \r\n                        if(!neighbour.isClosed){\r\n                            neighbourNodes.push(neighbour)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return neighbourNodes\r\n}\r\n\r\nexport const Pathfind = grid => {\r\n    let currentNode\r\n    let maxLoops = 100\r\n    let path = []\r\n    const startNode = grid.find(node => node.start === true)\r\n    const endNode = grid.find(node => node.end === true)\r\n    startNode.gCost = 0\r\n    startNode.hCost = findDistance(endNode,startNode)\r\n\r\n    currentNode = startNode\r\n    do{\r\n        let neighbours = findNeighbourNodes(grid,currentNode)\r\n        neighbours.forEach(neighbour => {\r\n            if(neighbour.isOpen){\r\n                if(neighbour.gCost > (currentNode.gCost +(findDistance(currentNode,neighbour)*10))){\r\n                    neighbour.gCost = currentNode.gCost + (findDistance(currentNode,neighbour)*10)\r\n                    neighbour.parent = currentNode\r\n                    \r\n                }\r\n            }else{\r\n                addToOpenList(neighbour)\r\n                neighbour.hCost = findDistance(neighbour,endNode)*10\r\n                neighbour.gCost = findDistance(neighbour,currentNode)*14\r\n                neighbour.parent = currentNode\r\n                neighbour.openListIndex = openList.length\r\n                openList.push(neighbour)\r\n            }\r\n        })\r\n\r\n        closeNode(currentNode)\r\n        openList.splice(currentNode.openListIndex,1)\r\n\r\n        currentNode = getLowestFCost()\r\n\r\n        if(currentNode === endNode){\r\n            while(currentNode.parent){\r\n                path.push(currentNode)\r\n                currentNode.path = true\r\n                currentNode = currentNode.parent\r\n            }\r\n            path.push(currentNode)\r\n            currentNode.path = true\r\n            console.log(openList)\r\n            return path\r\n        }\r\n\r\n        maxLoops--\r\n\r\n    }while(currentNode && maxLoops !== 0)\r\n    \r\n    return path\r\n}","import React from 'react'\nimport { Grid } from './Grid'\nexport const App = () => {\n  return (\n      <Grid/>\n  )\n}\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry)\n      getFID(onPerfEntry)\n      getFCP(onPerfEntry)\n      getLCP(onPerfEntry)\n      getTTFB(onPerfEntry)\n    })\n  }\n}\n\nexport default reportWebVitals\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport {App} from './App'\nimport reportWebVitals from './reportWebVitals'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}