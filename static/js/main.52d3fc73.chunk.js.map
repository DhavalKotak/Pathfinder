{"version":3,"sources":["Grid.js","Node.js","Pathfinder.js","App.js","reportWebVitals.js","index.js"],"names":["Node","props","start","className","style","backgroundColor","borderColor","end","close","path","seen","open","openList","findDistance","node","endNode","x","Math","abs","y","fCost","gCost","hCost","getLowestFCost","lowestNode","forEach","isOpen","findNeighbourNodes","grid","neighbour","neighbourNodes","i","j","find","item","id","isClosed","push","initialGrid","parent","openListIndex","Grid","gridRef","useRef","map","useState","setGrid","changeNode","e","right","currentGrid","current","floor","clientX","offsetLeft","clientWidth","ceil","clientY","offsetTop","button","newNodes","startNode","preventDefault","blockNode","Fragment","onMouseDown","onContextMenu","ref","onClick","currentNode","maxLoops","length","splice","Pathfind","alert","pathNode","marginTop","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.52d3fc73.chunk.js","sourcesContent":["import React, { useRef,useState } from 'react'\r\nimport { Node } from './Node'\r\nimport { startNode, endNode, blockNode, Pathfind } from './Pathfinder'\r\n\r\nconst initialGrid = []\r\nlet id = 1\r\n    for(let i = 9;i >= 0; i--){\r\n        for(let j = 0;j <= 9; j++){\r\n            initialGrid.push({\r\n                id: id,\r\n                x: j,\r\n                y: i,\r\n                gCost: 0,\r\n                hCost: 0,\r\n                parent: null,\r\n                isOpen: false,\r\n                isClosed: false,\r\n                seen: false,\r\n                start: false,\r\n                end: false,\r\n                openListIndex : 0,\r\n                path: false\r\n            })\r\n            id++\r\n        }\r\n    }\r\n\r\nexport const Grid = () => {\r\n    \r\n    const gridRef = useRef()\r\n    const map = []\r\n    const [grid,setGrid] = useState(initialGrid)\r\n\r\n    const changeNode = (e,right) => {\r\n        const currentGrid = gridRef.current\r\n        let x = Math.floor((e.clientX - currentGrid.offsetLeft)/(currentGrid.clientWidth/10))\r\n        let y = Math.abs(Math.ceil((e.clientY - currentGrid.offsetTop - currentGrid.clientWidth)/(currentGrid.clientWidth/10)))\r\n        if(e.button === 0 && right === 0){\r\n            let newNodes = startNode(x,y,grid)\r\n            setGrid(newNodes)\r\n        }else if(e.button === 2 && right === 1){\r\n            e.preventDefault()\r\n            let newNodes = endNode(x,y,grid)\r\n            setGrid(newNodes)\r\n        }else if(e.button === 1 && right === 0){\r\n            let newNodes = blockNode(x,y,grid)\r\n            setGrid(newNodes)\r\n        }\r\n    }\r\n    const start = () => {\r\n        let path = Pathfind(grid)\r\n        if(path.length === 0){\r\n            alert(\"no path\")\r\n        }\r\n        let newNodes = []\r\n        grid.forEach(node => {\r\n            let item = path.find(pathNode => pathNode.id === node.id)\r\n            if(item)\r\n                newNodes.push(item)\r\n            else\r\n                newNodes.push(node)\r\n            item = false\r\n        })\r\n        setGrid(newNodes)\r\n    }\r\n\r\n    grid.forEach(node => {\r\n        map.push(<Node key={node.id} x={node.x} y={node.y} start={node.start} end={node.end} close={node.isClosed} open={node.isOpen} path={node.path} seen={node.seen}/>)\r\n    })\r\n    \r\n    return(\r\n        <React.Fragment>\r\n            <div className='grid' onMouseDown={e => changeNode(e,0)} onContextMenu={e => {changeNode(e,1)}} ref={gridRef}>\r\n                {map}\r\n            </div>\r\n            <button className='btn-lg btn-primary' onClick={start} style={{marginTop:'30px'}}>Start</button>\r\n        </React.Fragment>\r\n    )\r\n}","import React from 'react'\r\n\r\nexport const Node = (props) => {\r\n    if(props.start === true){\r\n        return(\r\n            <div className='node' style={{backgroundColor: 'red',borderColor: 'grey'}}>\r\n                \r\n            </div>\r\n        )\r\n    }else if(props.end === true){\r\n        return(\r\n            <div className='node' style={{backgroundColor: 'blue',borderColor: 'grey'}}>\r\n                \r\n            </div>\r\n        )\r\n    }else if(props.close === true && props.path === false && props.seen === false){\r\n        return(\r\n            <div className='node close'>\r\n                \r\n            </div>\r\n        )\r\n    }else if(props.open === true){\r\n        return(\r\n            <div className='node open'>\r\n                \r\n            </div>\r\n        )\r\n    }else if(props.path === true){\r\n        return(\r\n            <div className='node path'>\r\n                \r\n            </div>\r\n        )\r\n    }else{\r\n        return(\r\n            <div className='node'>\r\n\r\n            </div>\r\n        )\r\n    }\r\n    \r\n}","const openList = []\r\n\r\nexport const startNode = (x,y,grid) => {\r\n    let newNodes = grid.map(node => {\r\n        if(node.start && (node.x !== x || node.y !== y))\r\n            node.start = false\r\n        if(node.x === x && node.y === y){\r\n            node.start = !node.start\r\n            if(node.end)\r\n                node.end = false\r\n            if(node.isClosed)\r\n                node.isClosed = false\r\n        }\r\n        return node\r\n    })\r\n    return newNodes\r\n}\r\n\r\nexport const endNode = (x,y,grid) => {\r\n    let newNodes = grid.map(node => {\r\n        if(node.end && (node.x !== x || node.y !== y))\r\n            node.end = false\r\n        if(node.x === x && node.y === y){\r\n            node.end = !node.end\r\n            if(node.isClosed)\r\n                node.isClosed = false\r\n            if(node.start)\r\n                node.start = false\r\n        }\r\n        return node\r\n    })\r\n    return newNodes\r\n}\r\n\r\nexport const blockNode = (x,y,grid) => {\r\n    let newNodes = grid.map(node => {\r\n        if(node.x === x && node.y === y){\r\n            node.isClosed = !node.isClosed\r\n            if(node.end)\r\n                node.end = false\r\n            if(node.start)\r\n                node.start = false\r\n        }\r\n        return node\r\n    })\r\n    return newNodes\r\n}\r\n\r\nexport const addToOpenList = node => {\r\n    node.isOpen = true\r\n    openList.push(node)\r\n}\r\n\r\nexport const closeNode = node => {\r\n    node.seen = true\r\n    node.isOpen = false\r\n    node.isClosed = true\r\n}\r\n\r\nexport const findDistance = (node,endNode) => {\r\n    let x = Math.abs(endNode.x - node.x)\r\n    let y = Math.abs(endNode.y - node.y)\r\n    if(x === 0 || y === 0)\r\n        return (x + y)*10\r\n    else{\r\n        if(x < y)\r\n            return x*4 + y*10\r\n        if(x > y)\r\n            return x*10 + y*4\r\n        else\r\n            return x*14\r\n    }\r\n}\r\n\r\nexport const fCost = node => {\r\n    return node.gCost + node.hCost\r\n}\r\n\r\nexport const getLowestFCost = () => {\r\n    let lowestNode = false\r\n    openList.forEach(node => {\r\n        if(node.isOpen){\r\n            if(!lowestNode){\r\n                lowestNode = node\r\n            }else if(fCost(node) < fCost(lowestNode)){\r\n                lowestNode = node\r\n            }else if(fCost(node) === fCost(lowestNode)){\r\n                if(node.hCost <= lowestNode.hCost)\r\n                    lowestNode = node\r\n            }\r\n        }\r\n    })\r\n    return lowestNode\r\n}\r\n\r\nexport const findNeighbourNodes = (grid,node) => {\r\n    let neighbourNodes = []\r\n    let neighbour\r\n    for(let i = -1; i<=1;i++){\r\n        for(let j = -1; j<=1;j++){\r\n            if(!(i === 0 && j === 0)){\r\n                if(i===-1)\r\n                    neighbour = grid.find(item => node.id+j-10 === item.id)\r\n                else if(i===0)\r\n                    neighbour = grid.find(item => node.id+j === item.id)\r\n                else if(i===1)\r\n                    neighbour = grid.find(item => node.id+10+j === item.id)\r\n            }\r\n            if(neighbour){\r\n                if(!(i === 0 && j === 0)){\r\n                    if(!neighbour.isClosed){\r\n                        if(node.x === 0 && j===-1)\r\n                            continue\r\n                        else if(node.x === 9 && j===1)\r\n                            continue\r\n                        else\r\n                            neighbourNodes.push(neighbour)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return neighbourNodes\r\n}\r\n\r\nexport const Pathfind = grid => {\r\n    let currentNode\r\n    let maxLoops = 100\r\n    let path = []\r\n    const startNode = grid.find(node => node.start === true)\r\n    const endNode = grid.find(node => node.end === true)\r\n    startNode.gCost = 0\r\n    startNode.hCost = findDistance(endNode,startNode)\r\n\r\n    currentNode = startNode\r\n    do{\r\n        let neighbours = findNeighbourNodes(grid,currentNode)\r\n        neighbours.forEach(neighbour => {\r\n            if(neighbour.isOpen){\r\n                if(neighbour.gCost > (currentNode.gCost + findDistance(currentNode,neighbour))){\r\n                    neighbour.gCost = currentNode.gCost + findDistance(currentNode,neighbour)\r\n                    neighbour.parent = currentNode\r\n                }\r\n            }else{\r\n                addToOpenList(neighbour)\r\n                neighbour.hCost = findDistance(neighbour,endNode)\r\n                neighbour.gCost = findDistance(neighbour,currentNode)\r\n                neighbour.parent = currentNode\r\n                neighbour.openListIndex = openList.length\r\n                openList.push(neighbour)\r\n            }\r\n        })\r\n\r\n        closeNode(currentNode)\r\n        openList.splice(currentNode.openListIndex,1)\r\n\r\n        currentNode = getLowestFCost()\r\n\r\n        if(currentNode === endNode){\r\n            while(currentNode.parent){\r\n                path.push(currentNode)\r\n                currentNode.path = true\r\n                currentNode = currentNode.parent\r\n            }\r\n            path.push(currentNode)\r\n            currentNode.path = true\r\n            return path\r\n        }\r\n\r\n        maxLoops--\r\n\r\n    }while(currentNode && maxLoops !== 0)\r\n\r\n    return path\r\n}\r\n","import React from 'react'\nimport { Grid } from './Grid'\nexport const App = () => {\n  return (\n      <Grid/>\n  )\n}\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry)\n      getFID(onPerfEntry)\n      getFCP(onPerfEntry)\n      getLCP(onPerfEntry)\n      getTTFB(onPerfEntry)\n    })\n  }\n}\n\nexport default reportWebVitals\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport {App} from './App'\nimport reportWebVitals from './reportWebVitals'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}